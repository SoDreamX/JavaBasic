一.进程和线程区别:
	进程：每个进程都有独立的代码和数据空间(进程上下文),进程间的切换有较大的开销,一个进程包含n个线程。(进程是资源分配的最小单位)
	线程：同一类线程共享代码和数据空间,每个线程有独立的运行栈和程序计数器(PC),线程切换开销小。(线程是cpu调度的最小单位)
	
	附：线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
	       多进程是指操作系统能同时运行多个任务（程序）。
　　          多线程是指在同一程序中有多个顺序流在执行。
二.实现Runnable接口比继承Thread类所具有的优势：
	1.适合多个相同的程序代码的线程去处理同一资源。
	2.可以避免java中单继承的限制
	3.增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。
	4.线程池只能放入实现Runnable和Callable类线程，不能直接放入继承Thread的类。
	附：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。
三.线程的各个状态：
	1.新建状态(New):新创建了一个线程对象。
	2.就绪状态(Runnable):线程对象创建后，其他线程调用了该线程对象的start()方法。
	     该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
	3.运行状态(Running):就绪状态下的线程获取了CPU，执行程序代码。
	4.阻塞状态(Blocked):阻塞状态是因为线程因为某些原因放弃了CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞状态分三种：
		(一)、等待阻塞：运行的线程执行wait()方法，JVM会把线程放到等待池中。(wait会释放持有的锁)
		(二)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		(三)、其他阻塞：运行的线程执行sleep()或join()方法时，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep等待超时，
			join等待线程终止或超时，I/O处理完毕时，线程重新转为就绪状态。(sleep不会释放持有的锁)
	5.死亡状态(Dead):线程执行完了或者因为异常退出了run()方法，该线程结束生命周期。
四.wait和sleep的区别：
共同点：
	1.他们在多线程环境下，都可以在程序的调用处阻塞指定的毫秒数并返回。
	2.都可以通过interrupt()方法打断线程的暂停状态，从而使线程抛出InterruptedException。
不同点：
	1.Thread类的方法：sleep(),yield()等。Object类的方法：wait(),notofy()等。
	2.每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。
	  sleep方法没有释放锁，wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
	3.wait,notify,notifyAll只能在同步控制方法或控制块里使用，sleep可以在任何地方使用。
	4.sleep必需捕获异常，而wait,notify,notifyAll不需要捕获异常。
五.线程类的一些常用方法：
	sleep():使一个线程睡眠N毫秒。
	isAlive():判断一个线程是否存活。
	join():等待线程终止。
	activeCount():程序中活跃的线程数。
	currentThread():得到当前的线程。
	isDaemon():一个线程是否为守护线程。
	setDaemon():设置线程为守护线程。
	setPriority():设置一个线程的优先级。
	wait():使一个线程等待。
	notify():通知一个线程继续运行。
六.多线程有什么用?
	1.发挥多核CPU的优势。
	2.防止阻塞。
	3.便于建模。
七.start和run的区别：
	只有调用start方法，才能表现多线程的特性，不同线程run方法里的代码交替执行。
	如果只调用run方法，那么代码还是同步执行的，必须等待一个线程run方法执行完毕，其他线程的run方法才能执行。
八.Runnable和Callable的区别：
	Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
	Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

九.线程池的作用
	1、减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务
	2、可以根据系统的承受能力，调整线程池中工作线程的数据，防止因为消耗过多的内存导致服务器崩溃