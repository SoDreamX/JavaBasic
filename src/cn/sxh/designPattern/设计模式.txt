设计模式：
1.设计模式6大原则：
	(1).开闭原则OCP：对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，
			这也是为了使程序的扩展性更好、易于升级和维护。
	(2).里氏代换原则LSP：里氏代换原则的程序表现就是：在程序中尽量使用基类类型来对对象进行定义，
			而在运行时再确定其子类类型，用子类对象来替换父类。
	(3).控制反转原则IOC：针对接口编程，依赖抽象而不依赖于具体。
	(4).接口隔离原则ISP：使用多个隔离的接口比用单个接口好。
	(5).迪米特法则DP：一个实体应当尽量少地与其他实体间发生相互作用，使得系统功能模块相对独立。
	(6).合成复用原则：尽量使用组合/聚合的方式，而不是使用继承。
2.简单工厂模式：简单工厂模式或者说工厂模式的关注点并不在于在工厂中是如何生产出来需要的类的，而在于将创建产品与消费产品分离。(解耦)
3.工厂方法模式：工厂方法模式是对简单工厂模式进一步抽象的结果。
	工厂方法模式是类的创建模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工厂推迟到子类中。
4.单例模式
	作为一种重要的设计模式，单例模式的好处有：
	(1)、控制资源的使用，通过线程同步来控制资源的并发访问
	(2)、控制实例的产生，以达到节约资源的目的
	(3)、控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信
5.原型模式
	一般由三个角色组成：
	(1)、客户角色--发出创建对象的请求
	(2)、抽象原型角色--接口或抽象类，提供具体原型类
	(3)、具体原型角色--被复制的角色，实现抽象原型角色的接口
	优点：
	(1)、比直接new一个对象在性能上好得多
	(2)、简化对象的创建，使得创建对象就像普通的复制黏贴一样简单。
6.策略模式
	策略模式是针对一组算法，将每一个算法封装到具有共同接口的独立类中。
	策略模式三个角色：
	(1)、环境角色--持有一个策略Strategy的引用
	(2)、抽象策略角色--具体策略类所需的接口或抽象类
	(3)、具体策略角色--包装了相关算法或行为
	策略模式的用处：
	(1)、用于购物系统，避免了多重条件if...else if...else语句；
	(2)、使得代码更优雅、更易维护
	(3)、策略模式在Java中典型的应用就是:Collections带Comparator的sort重载方法，
		会根据传入的不同的比较器Comparator，去执行不同的算法。
	(4)、缺点是客户端必须了解所有的策略类，才能使用。
7.适配器模式
	适配器模式的核心就是：可以把一个类的接口变换成客户端所期待的另一种接口。
	InputStreamReader就是适配器的应用实例：InputStream是源接口的实例对象，Reader是目标接口，
	InputStreamReader就是适配器，将InputStream适配到Reader;
	优点：(1)、有更好的复用性。(2)、有更好的扩展性。
	缺点：过多使用适配器会使得系统非常凌乱。
8.迭代器模式
	作用是提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节。
	优点：(1)、简化遍历方式。(2)、遍历方式多样。(3)、封装性好。
9.代理模式
	给某一对象提供一个代理对象，并由代理对象控制对原对象的引用。
	动态代理的核心就是将公共的逻辑抽象到InvocationHandler中。
	关于动态代理，JDK本身提供了支持，实现InvocationHandler接口即可。
	动态代理优点：(1)、代码简洁。(2)、可以在不修改原来代码的基础上，就在原来代码的基础上做操作，这就是AOP即面向切面编程。
10.观察者模式
	也称为发布-订阅模式，多个观察者对象同时监听一个主题对象，当主题对象状态改变时，通知所有观察者对象更新自己。
	JAVA中提供了观察者接口Observer，主题对象类Observable。
	优点：(1)、去重复代码，使得代码更清晰，更易扩展。(2)、解耦，使得代码可维护性更好。
	应用场景：(1)、对一个对象状态的更新需要其他对象同步更新。
		(2)、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节，如消息推送。
11.外观模式
	又称门面模式，是对象的结构模式，外部与一个子系统的通信必须通过一个统一的外观对象进行。
	优点：(1)、松散耦合：松散了客户端和子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
		(2)、简单易用：客户端不需要了解系统内部的实现，也不需要和众多子系统内部的模块交互，只需要和外观类交互就可以了。
		(3)、更好地划分层次：通过合理使用Facade，可以帮助我们更好地划分层次。有些方法是系统对内的，有些方法是对外的，
			把需要暴露给外部的功能集中到Facade中，这样既方便客户端使用，也很好地隐藏了内部的细节。
12.装饰器模式
	装饰器模式以多客户端透明的方式扩展对象的功能，是继承关系的一种替代方案。
	字节输入流InputStream采用了装饰器模式：
	(1)、InputStream是一个抽象构件角色。(2)、FileInputStream是具体构建角色。
	(3)、FilterInputStream是一个装饰角色，因为FilterInputStream实现了InputStream内的
		所有抽象方法并且持有一个InputStream的引用。
	(4)、具体装饰角色就是BufferedInputStream等。
	