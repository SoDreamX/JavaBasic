设计模式：
1.设计模式6大原则：
	(1).开闭原则OCP：对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，
			这也是为了使程序的扩展性更好、易于升级和维护。
	(2).里氏代换原则LSP：里氏代换原则的程序表现就是：在程序中尽量使用基类类型来对对象进行定义，
			而在运行时再确定其子类类型，用子类对象来替换父类。
	(3).控制反转原则IOC：针对接口编程，依赖抽象而不依赖于具体。
	(4).接口隔离原则ISP：使用多个隔离的接口比用单个接口好。
	(5).迪米特法则DP：一个实体应当尽量少地与其他实体间发生相互作用，使得系统功能模块相对独立。
	(6).合成复用原则：尽量使用组合/聚合的方式，而不是使用继承。
2.简单工厂模式：简单工厂模式或者说工厂模式的关注点并不在于在工厂中是如何生产出来需要的类的，而在于将创建产品与消费产品分离。(解耦)
3.工厂方法模式：工厂方法模式是对简单工厂模式进一步抽象的结果。
	工厂方法模式是类的创建模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工厂推迟到子类中。
4.单例模式
	作为一种重要的设计模式，单例模式的好处有：
	(1)、控制资源的使用，通过线程同步来控制资源的并发访问
	(2)、控制实例的产生，以达到节约资源的目的
	(3)、控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信
5.原型模式
	一般由三个角色组成：
	(1)、客户角色--发出创建对象的请求
	(2)、抽象原型角色--接口或抽象类，提供具体原型类
	(3)、具体原型角色--被复制的角色，实现抽象原型角色的接口
	优点：
	(1)、比直接new一个对象在性能上好得多
	(2)、简化对象的创建，使得创建对象就像普通的复制黏贴一样简单。
6.策略模式
	策略模式是针对一组算法，将每一个算法封装到具有共同接口的独立类中。
	策略模式三个角色：
	(1)、环境角色--持有一个策略Strategy的引用
	(2)、抽象策略角色--具体策略类所需的接口或抽象类
	(3)、具体策略角色--包装了相关算法或行为
	策略模式的用处：
	(1)、用于购物系统，避免了多重条件if...else if...else语句；
	(2)、使得代码更优雅、更易维护
	(3)、策略模式在Java中典型的应用就是:Collections带Comparator的sort重载方法，
		会根据传入的不同的比较器Comparator，去执行不同的算法。
	(4)、缺点是客户端必须了解所有的策略类，才能使用。
7.适配器模式
	适配器模式的核心就是：可以把一个类的接口变换成客户端所期待的另一种接口。
	InputStreamReader就是适配器的应用实例：InputStream是源接口的实例对象，Reader是目标接口，
	InputStreamReader就是适配器，将InputStream适配到Reader;
	优点：(1)、有更好的复用性。(2)、有更好的扩展性。
	缺点：过多使用适配器会使得系统非常凌乱。
8.迭代器模式
	作用是提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节。
	优点：(1)、简化遍历方式。(2)、遍历方式多样。(3)、封装性好。
9.代理模式
	给某一对象提供一个代理对象，并由代理对象控制对原对象的引用。
	动态代理的核心就是将公共的逻辑抽象到InvocationHandler中。
	关于动态代理，JDK本身提供了支持，实现InvocationHandler接口即可。
	动态代理优点：(1)、代码简洁。(2)、可以在不修改原来代码的基础上，就在原来代码的基础上做操作，这就是AOP即面向切面编程。
